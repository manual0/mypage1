[{"content":"\rMySQL 安装 #\r安装 MySQL 对于基于 Debian 的系统（如 Ubuntu）:\nsudo apt update sudo apt install mysql-server 对于基于 Red Hat 的系统（如 CentOS）:\nsudo yum install mysql-server 安全配置 #\rsudo mysql_secure_installation 这里会让你选密码等级，我选的 2（最高等级）。\n细节配置 #\r然后会有一系列介绍，全选 y 也没问题，下面是选项的一些解释。\n匿名用户 默认情况下，MySQL 安装完成后会创建一个匿名用户，这个用户可以无需账户就能登录 MySQL。这通常用于测试或简化安装过程，但如果你打算将 MySQL 用于生产环境，则强烈建议你删除这个匿名用户，以确保安全性。\n禁止 root 用户的远程登录 MySQL 的 root 用户被设置为只能从 localhost（本地）登录，这是一种安全措施，防止黑客通过网络尝试猜测 root 密码。如果允许 root 远程登录，系统将面临更大的安全风险，尤其是在生产环境中。因此，通常建议禁止 root 的远程登录，只允许其在服务器本地进行操作。\n默认的 test 数据库 MySQL 默认会创建一个名为 test 的数据库，任何用户都可以访问它。这个数据库主要用于测试目的，并不具备严格的访问控制。\n重新加载权限表 MySQL 的权限表（privilege tables）存储了所有用户的权限信息。进行用户管理、更改权限、删除匿名用户等操作后，需要重新加载这些表，才能使更改生效。这个过程不会中断 MySQL 服务，只是让你所做的更改立刻生效。\n启动 MySQL 服务 #\rsudo systemctl start mysql sudo systemctl enable mysql 如图，成功启动\n基本使用 #\rcreate database helloworld; #创建数据库：create database 数据库名 show databases;#查看已存在的数据库，一般会默认存在些 use helloworld; #使用表 create table student( #创建初始表格 name varchar(32), age int, gender varchar(2) ); show tables;#查看创建好的表 insert into student(name,age,gender) value(\u0026#39;张三\u0026#39;,20,\u0026#39;男\u0026#39;); #插入数据到表格中： select * from student;#查看表的内容 建立数据库，本质就是创建一个文件，一顿操作下来如图，成功使用。 ","date":"2025-12-01","externalUrl":null,"permalink":"/posts/mypage6/","section":"Posts","summary":"MySQL 安装 #\r安装 MySQL 对于基于 Debian 的系统（如 Ubuntu）:","title":"Linux系统配置安装MySQL","type":"posts"},{"content":"","date":"2025-12-01","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"2025-12-01","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2025-12-01","externalUrl":null,"permalink":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/","section":"Tags","summary":"","title":"数据库","type":"tags"},{"content":"","date":"2025-12-01","externalUrl":null,"permalink":"/tags/%E5%AD%A6%E4%B9%A0/","section":"Tags","summary":"","title":"学习","type":"tags"},{"content":"","date":"2025-12-01","externalUrl":null,"permalink":"/","section":"又木的学习空间","summary":"","title":"又木的学习空间","type":"page"},{"content":"\r波兰式 #\r中缀转前缀 #\r要将一个中缀表达式转换为前缀表达式，可以通过栈的方式实现。中缀表达式是我们日常书写的算式形式，比如 (A + B) * C，而前缀表达式（也叫波兰表达式）是一种操作符位于操作数前面的表示方法，例如 * + A B C。\n转换规则： #\r操作符的优先级：在转换过程中，优先级需要考虑，例如： * 和 / 的优先级高于 + 和 -。 括号的优先级最高。 栈的使用： 遇到操作数（数字或变量）时，直接添加到输出。 遇到操作符时，按照优先级将栈中较高优先级的操作符弹出，直到栈顶的操作符优先级低于当前操作符或栈为空，然后将当前操作符压入栈中。 遇到左括号 ( 时，压入栈中。 遇到右括号 ) 时，弹出栈中的操作符直到遇到左括号为止，并将操作符输出。 最终结果：在表达式遍历完毕后，栈中可能会有剩余的操作符，逐一弹出并加入结果中。 解决思路： #\r步骤一：将中缀表达式转换为后缀表达式（逆波兰表达式）。 步骤二：将后缀表达式再转换为前缀表达式。 其实，将中缀表达式直接转换为前缀表达式与转换为后缀表达式的步骤基本相同，只是操作顺序反转。为了简洁起见，下面是直接从中缀表达式转换为前缀表达式的实现。\n中缀转前缀表达式的算法： #\r反转中缀表达式：将中缀表达式的括号反转（即 ( 变为 )，) 变为 (），并反转表达式中的字符顺序。 按中缀转后缀的方法转换：利用栈按顺序转换中缀表达式为后缀表达式。 反转结果：将得到的后缀表达式再反转一次，得到前缀表达式。 代码实现： #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; #define MAX 100 // 用于存储操作符优先级 int precedence(char c) { if (c == \u0026#39;+\u0026#39; || c == \u0026#39;-\u0026#39;) return 1; if (c == \u0026#39;*\u0026#39; || c == \u0026#39;/\u0026#39;) return 2; if (c == \u0026#39;^\u0026#39;) return 3; // ^ 的优先级最高 return 0; } // 判断字符是否是操作数（数字或字母） int isOperand(char c) { return isalpha(c) || isdigit(c); } // 反转字符串 void reverse(char* expr) { int len = strlen(expr); for (int i = 0; i \u0026lt; len / 2; i++) { char temp = expr[i]; expr[i] = expr[len - i - 1]; expr[len - i - 1] = temp; } } // 中缀转后缀的函数 void infixToPostfix(char* infix, char* postfix) { char stack[MAX]; int top = -1, k = 0; for (int i = 0; infix[i] != \u0026#39;\\0\u0026#39;; i++) { char token = infix[i]; // 如果是操作数，直接放入后缀表达式 if (isOperand(token)) { postfix[k++] = token; } // 如果是左括号，压入栈 else if (token == \u0026#39;(\u0026#39;) { stack[++top] = token; } // 如果是右括号，弹出栈直到遇到左括号 else if (token == \u0026#39;)\u0026#39;) { while (top != -1 \u0026amp;\u0026amp; stack[top] != \u0026#39;(\u0026#39;) { postfix[k++] = stack[top--]; } top--; // 弹出左括号 } // 如果是操作符，按优先级处理栈 else { while (top != -1 \u0026amp;\u0026amp; precedence(stack[top]) \u0026gt;= precedence(token)) { postfix[k++] = stack[top--]; } stack[++top] = token; } } // 弹出栈中所有剩余的操作符 while (top != -1) { postfix[k++] = stack[top--]; } postfix[k] = \u0026#39;\\0\u0026#39;; } // 中缀转前缀的函数 void infixToPrefix(char* infix, char* prefix) { // 1. 反转中缀表达式 reverse(infix); // 2. 替换括号 for (int i = 0; infix[i] != \u0026#39;\\0\u0026#39;; i++) { if (infix[i] == \u0026#39;(\u0026#39;) { infix[i] = \u0026#39;)\u0026#39;; } else if (infix[i] == \u0026#39;)\u0026#39;) { infix[i] = \u0026#39;(\u0026#39;; } } // 3. 获取后缀表达式 char postfix[MAX]; infixToPostfix(infix, postfix); // 4. 反转后缀表达式得到前缀表达式 reverse(postfix); strcpy(prefix, postfix); } int main() { char infix[MAX], prefix[MAX]; // 输入中缀表达式 printf(\u0026#34;Enter infix expression: \u0026#34;); scanf(\u0026#34;%s\u0026#34;, infix); // 转换为前缀表达式 infixToPrefix(infix, prefix); // 输出前缀表达式 printf(\u0026#34;Prefix expression: %s\\n\u0026#34;, prefix); return 0; } 代码说明： #\rprecedence 函数：用来判断操作符的优先级，+ 和 - 的优先级为 1，* 和 / 为 2，^ 为 3。\nisOperand 函数：判断一个字符是否是操作数，即数字或字母。\nreverse 函数：用来反转字符串，作为中缀转前缀的一部分。\ninfixToPostfix 函数：将中缀表达式转换为后缀表达式。使用栈来处理操作符，根据优先级和括号来安排操作符的顺序。\ninfixToPrefix 函数：\n完成中缀到前缀的转换。步骤如下：\n反转中缀表达式； 替换括号； 使用 infixToPostfix 函数转换为后缀表达式； 反转后缀表达式，得到前缀表达式。 main 函数：从标准输入读取中缀表达式，调用 infixToPrefix 函数进行转换，最后输出前缀表达式。\n样例输入与输出： #\r输入： #\rEnter infix expression: (A-B/C)*(A/K-L) 输出： #\rPrefix expression: *-A/BC-AKL 解释： #\r对于中缀表达式 (A-B/C)*(A/K-L)，它的前缀表达式为 *-A/BC-AKL。 时间复杂度： #\r每次遍历中缀表达式的时间复杂度为 O(n)，其中 n 是中缀表达式的长度。 反转字符串的时间复杂度也是 O(n)，因此总的时间复杂度为 O(n)。 空间复杂度： #\r栈的空间复杂度为 O(n)，其中 n 是中缀表达式的长度。 总结： #\r此代码实现了中缀表达式到前缀表达式的转换，通过反转字符串和括号、转换为后缀表达式，然后再反转后缀得到前缀表达式的方式高效完成了转换过程。\n根据后缀表达式求值 #\r求值后缀表达式（逆波兰表达式）可以通过栈来实现，利用栈的特性，操作数入栈，操作符弹出栈顶两个操作数进行运算，并将结果再压入栈中。直到整个表达式处理完，栈中的唯一元素就是最终结果。\n后缀表达式求值的步骤： #\r初始化一个栈：用来存储操作数。 遍历后缀表达式： 如果遇到操作数（数字），将其压入栈中。 如果遇到操作符（如 +, -, *, /），从栈中弹出两个操作数，进行计算，然后将结果压回栈中。 表达式遍历完成后，栈中的唯一元素即为结果。 处理的操作符： #\r加法 (+) 减法 (-) 乘法 (*) 除法 (/) 代码实现： #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; #include \u0026lt;string.h\u0026gt; // 计算两个数的运算结果 int applyOperator(int a, int b, char operator) { switch (operator) { case \u0026#39;+\u0026#39;: return a + b; case \u0026#39;-\u0026#39;: return a - b; case \u0026#39;*\u0026#39;: return a * b; case \u0026#39;/\u0026#39;: return a / b; default: return 0; } } // 后缀表达式求值 int evaluatePostfix(const char* postfix) { int stack[100]; // 栈存储操作数 int top = -1; // 栈顶指针 for (int i = 0; postfix[i] != \u0026#39;\\0\u0026#39;; i++) { char token = postfix[i]; // 如果是数字，则入栈 if (isdigit(token)) { stack[++top] = token - \u0026#39;0\u0026#39;; // 将字符转换为数字并入栈 } // 如果是操作符，弹出两个数进行计算并将结果入栈 else if (token == \u0026#39;+\u0026#39; || token == \u0026#39;-\u0026#39; || token == \u0026#39;*\u0026#39; || token == \u0026#39;/\u0026#39;) { int b = stack[top--]; // 弹出栈顶元素 int a = stack[top--]; // 弹出栈次顶元素 int result = applyOperator(a, b, token); // 计算结果 stack[++top] = result; // 将结果压入栈 } } // 栈顶的唯一元素即为表达式的计算结果 return stack[top]; } int main() { char postfix[100]; // 输入后缀表达式 printf(\u0026#34;Enter postfix expression: \u0026#34;); scanf(\u0026#34;%s\u0026#34;, postfix); // 计算并输出结果 int result = evaluatePostfix(postfix); printf(\u0026#34;Result: %d\\n\u0026#34;, result); return 0; } 代码说明： #\rapplyOperator 函数：这个函数根据传入的操作符对两个操作数进行计算，支持四则运算。 evaluatePostfix 函数：该函数实现后缀表达式的求值，使用一个栈来存储操作数。当遇到操作符时，弹出栈顶的两个操作数，进行运算并将结果压入栈中，最后栈中剩下的就是表达式的值。 main 函数：从用户输入获取后缀表达式，调用 evaluatePostfix 函数进行计算，并输出结果。 样例输入与输出： #\r输入： #\rEnter postfix expression: 23*54*+ 输出： #\rResult: 110 解释： #\r后缀表达式 23*54*+ 可以分解为：\n2 * 3 = 6 5 * 4 = 20 6 + 20 = 26 所以结果为 26。\n扩展： #\r如果表达式中包含多位数（例如 12 34 +），则可以按以下方式处理：\n遇到多位数时，需要先解析出完整的数字，而不仅仅是一个字符。可以通过循环读取连续的数字字符并转换为完整的数值。 如果需要处理浮点数，也可以对 isdigit 进行适当修改，或者使用浮点数运算代替整数运算。\n时间复杂度： #\r时间复杂度：每个操作符和操作数都被遍历一次，因此时间复杂度是 O(n)，其中 n 是后缀表达式的长度。 空间复杂度：栈最多会存储 n 个操作数，因此空间复杂度是 O(n)。 根据前缀表达式求值 #\r根据前缀表达式求值的方法与后缀表达式求值非常相似，唯一的区别是前缀表达式的运算顺序与后缀表达式相反。具体来说，前缀表达式的运算从右到左进行，操作符先于操作数出现，因此我们需要从右向左扫描前缀表达式。\n前缀表达式求值的步骤： #\r初始化一个栈：用来存储操作数。 从右向左遍历前缀表达式： 如果遇到操作数（数字），将其压入栈中。 如果遇到操作符（如 +, -, *, /），从栈中弹出两个操作数，进行计算，然后将结果再压回栈中。 表达式遍历完成后，栈中的唯一元素即为结果。 前缀表达式求值的算法： #\r从右向左扫描表达式： 如果是操作数（数字），将其压入栈中。 如果是操作符（如 +, -, *, /），从栈中弹出两个操作数，进行计算，并将结果压入栈中。 最后栈中只剩下一个元素，即为表达式的计算结果。 代码实现： #\r#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;ctype.h\u0026gt; #include \u0026lt;string.h\u0026gt; // 计算两个数的运算结果 int applyOperator(int a, int b, char operator) { switch (operator) { case \u0026#39;+\u0026#39;: return a + b; case \u0026#39;-\u0026#39;: return a - b; case \u0026#39;*\u0026#39;: return a * b; case \u0026#39;/\u0026#39;: return a / b; default: return 0; } } // 前缀表达式求值 int evaluatePrefix(const char* prefix) { int stack[100]; // 栈存储操作数 int top = -1; // 栈顶指针 // 从右向左遍历前缀表达式 for (int i = strlen(prefix) - 1; i \u0026gt;= 0; i--) { char token = prefix[i]; // 如果是数字，则入栈 if (isdigit(token)) { stack[++top] = token - \u0026#39;0\u0026#39;; // 将字符转换为数字并入栈 } // 如果是操作符，弹出两个数进行计算并将结果入栈 else if (token == \u0026#39;+\u0026#39; || token == \u0026#39;-\u0026#39; || token == \u0026#39;*\u0026#39; || token == \u0026#39;/\u0026#39;) { int a = stack[top--]; // 弹出栈顶元素 int b = stack[top--]; // 弹出栈次顶元素 int result = applyOperator(a, b, token); // 计算结果 stack[++top] = result; // 将结果压入栈 } } // 栈顶的唯一元素即为表达式的计算结果 return stack[top]; } int main() { char prefix[100]; // 输入前缀表达式 printf(\u0026#34;Enter prefix expression: \u0026#34;); scanf(\u0026#34;%s\u0026#34;, prefix); // 计算并输出结果 int result = evaluatePrefix(prefix); printf(\u0026#34;Result: %d\\n\u0026#34;, result); return 0; } 代码说明： #\rapplyOperator 函数：用于根据传入的操作符对两个操作数进行计算，支持四则运算。\nevaluatePrefix 函数\n：实现前缀表达式的求值。使用栈从右向左遍历前缀表达式：\n如果遇到操作数，直接压入栈中。 如果遇到操作符，从栈中弹出两个操作数，进行计算，并将结果压回栈中。 main 函数：从用户输入读取前缀表达式，调用 evaluatePrefix 函数进行计算，并输出结果。\n样例输入与输出： #\r输入： #\rEnter prefix expression: *+23-54 输出： #\rResult: 23 解释： #\r前缀表达式 *+23-54 可以分解为：\n+2 3 = 5 -5 4 = 1 5 * 1 = 5 因此，结果是 5。\n扩展： #\r如果表达式中包含多位数（例如 12 34 +），可以通过以下方式处理：\n遇到多位数时，需要解析出完整的数字，而不仅仅是一个字符，可以通过循环读取连续的数字字符并转换为完整的数值。 如果需要处理浮点数，也可以对 isdigit 进行适当修改，或者使用浮点数运算代替整数运算。\n时间复杂度： #\r时间复杂度：每个操作符和操作数都被遍历一次，因此时间复杂度是 O(n)，其中 n 是前缀表达式的长度。 空间复杂度：栈最多会存储 n 个操作数，因此空间复杂度是 O(n)。 总结： #\r此代码实现了前缀表达式的求值，通过栈从右到左扫描前缀表达式，在遇到操作符时弹出两个操作数进行计算，并将结果压回栈中，最终栈中的唯一元素即为计算结果。\n","date":"2025-05-09","externalUrl":null,"permalink":"/posts/mypage5/","section":"Posts","summary":"波兰式 #\r中缀转前缀 #\r要将一个中缀表达式转换为前缀表达式，可以通过栈的方式实现。中缀表达式是我们日常书写的算式形式，比如 (A + B) * C，而前缀表达式（也叫波兰表达式）是一种操作符位于操作数前面的表示方法，例如 * + A B C。","title":"波兰式","type":"posts"},{"content":"首先，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，需要你熟练掌握递归思维，只有列出正确的「[[状态转移方程]]」，才能正确地穷举。而且，你需要判断算法问题是否具备「[[最优子结构]]」，是否能够通过子问题的最值得到原问题的最值。另外，动态规划问题存在「重叠子问题」，如果暴力穷举的话效率会很低，所以需要你使用「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。\n框架： #\r# 自顶向下递归的动态规划 def dp(状态1, 状态2, ...): for 选择 in 所有可能的选择: # 此时的状态已经因为做了选择而改变 result = 求最值(result, dp(状态1, 状态2, ...)) return result # 自底向上迭代的动态规划 # 初始化 base case dp[0][0][...] = base case # 进行状态转移 for 状态1 in 状态1的所有取值： for 状态2 in 状态2的所有取值： for ... dp[状态1][状态2][...] = 求最值(选择1，选择2...) 例子： #\r[!example] 给你 k 种面值的硬币，面值分别为 c1, c2 ... ck，每种硬币的数量无限，再给一个总金额 amount，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。算法的函数签名如下：\n# coins 中是可选硬币面值，amount 是目标金额\rdef coinChange(coins: List[int], amount: int) -\u0026gt; int: 比如说 k = 3，面值分别为 1，2，5，总金额 amount = 11。那么最少需要 3 枚硬币凑出，即 11 = 5 + 5 + 1。\n这个问题是动态规划问题，满足具有最优子结构\n[!help]+ 假设你有面值为 1, 2, 5 的硬币，你想求 amount = 11 时的最少硬币数（原问题），如果你知道凑出 amount = 10, 9, 6 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1, 2, 5 的硬币），求个最小值，就是原问题的答案。因为硬币的数量是没有限制的，所以子问题之间没有相互制，是互相独立的。\n解法 #\r那么 首先，列出状态转移方程：\n确定「状态」，也就是原问题和子问题中会变化的变量。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 amount。\n确定「选择」，也就是导致「状态」产生变化的行为。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。\n明确 dp 函数/数组的定义。我们这里讲的是自顶向下的解法，所以会有一个递归的 dp 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。\nclass Solution: def coinChange(self, coins: List[int], amount: int) -\u0026gt; int: # 题目要求的最终结果是 dp(amount) return self.dp(coins, amount) # 定义：要凑出金额 n，至少要 dp(coins, n) 个硬币 def dp(self, coins, amount): # base case if amount == 0: return 0 if amount \u0026lt; 0: return -1 res = float(\u0026#39;inf\u0026#39;) for coin in coins: # 计算子问题的结果 subProblem = self.dp(coins, amount - coin) # 子问题无解则跳过 if subProblem == -1: continue # 在子问题中选择最优解，然后加一 res = min(res, subProblem + 1) return res if res != float(\u0026#39;inf\u0026#39;) else -1 优化： #\r带备忘录的解法： #\rclass Solution: def __init__(self): self.memo = [] def coinChange(self, coins: List[int], amount: int) -\u0026gt; int: self.memo = [-666] * (amount + 1) # 备忘录初始化为一个不会被取到的特殊值，代表还未被计算 return self.dp(coins, amount) def dp(self, coins, amount): if amount == 0: return 0 if amount \u0026lt; 0: return -1 # 查备忘录，防止重复计算 if self.memo[amount] != -666: return self.memo[amount] res = float(\u0026#39;inf\u0026#39;) for coin in coins: # 计算子问题的结果 subProblem = self.dp(coins, amount - coin) # 子问题无解则跳过 if subProblem == -1: continue # 在子问题中选择最优解，然后加一 res = min(res, subProblem + 1) # 把计算结果存入备忘录 self.memo[amount] = res if res != float(\u0026#39;inf\u0026#39;) else -1 return self.memo[amount] dp 数组迭代 #\r当然，我们也可以自底向上使用 dp table 来消除重叠子问题，关于「状态」「选择」和 base case 与之前没有区别，dp 数组的定义和刚才 dp 函数类似，也是把「状态」，也就是目标金额作为变量。不过 dp 函数体现在函数参数，而 dp 数组体现在数组索引： dp 数组的定义：当目标金额为 i 时，至少需要 dp[i] 枚硬币凑出。\nclass Solution: def coinChange(self, coins: List[int], amount: int) -\u0026gt; int: # 数组大小为 amount + 1，初始值也为 amount + 1 dp = [amount + 1] * (amount + 1) dp[0] = 0 # base case # 外层 for 循环在遍历所有状态的所有取值 for i in range(len(dp)): # 内层 for 循环在求所有选择的最小值 for coin in coins: # 子问题无解，跳过 if i - coin \u0026lt; 0: continue dp[i] = min(dp[i], 1 + dp[i - coin]) return -1 if dp[amount] == amount + 1 else dp[amount] [!info]- 为啥 dp 数组中的值都初始化为 amount + 1 呢，因为凑成 amount 金额的硬币数最多只可能等于 amount（全用 1 元面值的硬币），所以初始化为 amount + 1 就相当于初始化为正无穷，便于后续取最小值。为啥不直接初始化为 int 型的最大值 Integer.MAX_VALUE 呢？因为后面有 dp[i - coin] + 1，这就会导致整型溢出。\n","date":"2025-05-09","externalUrl":null,"permalink":"/posts/mypage2/","section":"Posts","summary":"首先，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，需要你熟练掌握递归思维，只有列出正确的「[[状态转移方程]]」，才能正确地穷举。而且，你需要判断算法问题是否具备「[[最优子结构]]」，是否能够通过子问题的最值得到原问题的最值。另外，动态规划问题存在「重叠子问题」，如果暴力穷举的话效率会很低，所以需要你使用「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。","title":"动态规划","type":"posts"},{"content":"\r二叉树算法纲领 #\r先在开头总结一下，二叉树解题的思维模式分两类：\n1、是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现，这叫「遍历」的思维模式。\n2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。\n无论使用哪种思维模式，你都需要思考：\n如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。\n深入理解前中后序 #\r我先甩给你几个问题，请默默思考 30 秒：\n1、你理解的二叉树的前中后序遍历是什么，仅仅是三个顺序不同的 List 吗？\n2、请分析，后序遍历有什么特殊之处？\n3、请分析，为什么多叉树没有中序遍历？\n答不上来，说明你对前中后序的理解仅仅局限于教科书，不过没关系，我用类比的方式解释一下我眼中的前中后序遍历。\n首先，回顾一下二叉树递归遍历框架：\ndef traverse(root): if root is None: return # 前序位置 traverse(root.left) # 中序位置 traverse(root.right) # 后序位置 先不管所谓前中后序，单看 traverse 函数，你说它在做什么事情？\n其实它就是一个能够遍历二叉树所有节点的一个函数，和你遍历数组或者链表本质上没有区别：\n单链表和数组的遍历可以是迭代的，也可以是递归的，二叉树这种结构无非就是二叉链表，它没办法简单改写成 for 循环的迭代形式，所以我们遍历二叉树一般都使用递归形式。\n你也注意到了，只要是递归形式的遍历，都可以有前序位置和后序位置，分别在递归之前和递归之后。\n所谓前序位置，就是刚进入一个节点（元素）的时候，后序位置就是即将离开一个节点（元素）的时候，那么进一步，你把代码写在不同位置，代码执行的时机也不同：\n比如说，如果让你倒序打印一条单链表上所有节点的值，你怎么搞？\n实现方式当然有很多，但如果你对递归的理解足够透彻，可以利用后序位置来操作：\n# 递归遍历单链表，倒序打印链表元素 def traverse(head): if head is None: return traverse(head.next) # 后序位置 print(head.val) 结合上面那张图，你应该知道为什么这段代码能够倒序打印单链表了吧，本质上是利用递归的堆栈帮你实现了倒序遍历的效果。\n那么说回二叉树也是一样的，只不过多了一个中序位置罢了。\n教科书里只会问你前中后序遍历结果分别是什么，所以对于一个只上过大学数据结构课程的人来说，他大概以为二叉树的前中后序只不过对应三种顺序不同的 List\u0026lt;Integer\u0026gt; 列表。\n但是我想说，前中后序是遍历二叉树过程中处理每一个节点的三个特殊时间点，绝不仅仅是三个顺序不同的 List：\n前序位置的代码在刚刚进入一个二叉树节点的时候执行；\n后序位置的代码在将要离开一个二叉树节点的时候执行；\n中序位置的代码在一个二叉树节点左子树都遍历完，即将开始遍历右子树的时候执行。\n你注意本文的用词，我一直说前中后序「位置」，就是要和大家常说的前中后序「遍历」有所区别：你可以在前序位置写代码往一个 List 里面塞元素，那最后得到的就是前序遍历结果；但并不是说你就不可以写更复杂的代码做更复杂的事。\n画成图，前中后序三个位置在二叉树上是这样：\n你可以发现每个节点都有「唯一」属于自己的前中后序位置，所以我说前中后序遍历是遍历二叉树过程中处理每一个节点的三个特殊时间点。\n这里你也可以理解为什么多叉树没有中序位置，因为二叉树的每个节点只会进行唯一一次左子树切换右子树，而多叉树节点可能有很多子节点，会多次切换子树去遍历，所以多叉树节点没有「唯一」的中序遍历位置。\n说了这么多基础的，就是要帮你对二叉树建立正确的认识，然后你会发现：\n二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，去达到自己的目的，你只需要单独思考每一个节点应该做什么，其他的不用你管，抛给二叉树遍历框架，递归会在所有节点上做相同的操作。\n两种解题思路 #\r**二叉树题目的递归解法可以分两类思路，第一类是遍历一遍二叉树得出答案，第二类是通过分解问题计算出答案，这两类思路分别对应着 [[回溯算法（DFS算法）]] 和 [[动态规划]]。\n[!tip]\n这里说一下我的函数命名习惯：二叉树中用遍历思路解题时函数签名一般是 void traverse(...)，没有返回值，靠更新外部变量来计算结果，而用分解问题思路解题时函数名根据该函数具体功能而定，而且一般会有返回值，返回值是子问题的计算结果。\n与此对应的，你会发现我在 [[回溯算法（DFS算法）]] 中给出的函数签名一般也是没有返回值的 void backtrack(...)，而在 [[动态规划]] 中给出的函数签名是带有返回值的 dp 函数。这也说明它俩和二叉树之间千丝万缕的联系。\n虽然函数命名没有什么硬性的要求，但我还是建议你也遵循我的这种风格，这样更能突出函数的作用和解题的思维模式，便于你自己理解和运用。\n当时我是用二叉树的最大深度这个问题来举例，重点在于把这两种思路和动态规划和回溯算法进行对比，而本文的重点在于分析这两种思路如何解决二叉树的题目。\n力扣第 104 题「二叉树的最大深度」就是最大深度的题目，所谓最大深度就是根节点到「最远」叶子节点的最长路径上的节点数，比如输入这棵二叉树，算法应该返回 3：\n你做这题的思路是什么？显然遍历一遍二叉树，用一个外部变量记录每个节点所在的深度，取最大值就可以得到最大深度，这就是遍历二叉树计算答案的思路。\n解法代码如下：\nclass Solution: def __init__(self): # 记录最大深度 self.res = 0 # 记录遍历到的节点的深度 self.depth = 0 def maxDepth(self, root: TreeNode) -\u0026gt; int: self.traverse(root) return self.res # 二叉树遍历框架 def traverse(self, root: TreeNode) -\u0026gt; None: if root is None: return # 前序位置 self.depth += 1 if root.left is None and root.right is None: # 到达叶子节点，更新最大深度 self.res = max(self.res, self.depth) self.traverse(root.left) self.traverse(root.right) # 后序位置 self.depth -= 1 这个解法应该很好理解，但为什么需要在前序位置增加 depth，在后序位置减小 depth？\n因为前面说了，前序位置是进入一个节点的时候，后序位置是离开一个节点的时候，depth 记录当前递归到的节点深度，你把 traverse 理解成在二叉树上游走的一个指针，所以当然要这样维护。\n至于对 res 的更新，你放到前中后序位置都可以，只要保证在进入节点之后，离开节点之前（即 depth 自增之后，自减之前）就行了。\n当然，你也很容易发现一棵二叉树的最大深度可以通过子树的最大深度推导出来，这就是分解问题计算答案的思路。\n解法代码如下：\nclass Solution: # 定义：输入根节点，返回这棵二叉树的最大深度 def maxDepth(self, root: TreeNode) -\u0026gt; int: if root is None: return 0 # 利用定义，计算左右子树的最大深度 leftMax = self.maxDepth(root.left) rightMax = self.maxDepth(root.right) # 整棵树的最大深度等于左右子树的最大深度取最大值， # 然后再加上根节点自己 res = max(leftMax, rightMax) + 1 return res 只要明确递归函数的定义，这个解法也不难理解，但为什么主要的代码逻辑集中在后序位置？\n因为这个思路正确的核心在于，你确实可以通过子树的最大深度推导出原树的深度，所以当然要首先利用递归函数的定义算出左右子树的最大深度，然后推出原树的最大深度，主要逻辑自然放在后序位置。\n如果你理解了最大深度这个问题的两种思路，那么我们再回头看看最基本的二叉树前中后序遍历，就比如力扣第 144 题「二叉树的前序遍历」，让你计算前序遍历结果。\n我们熟悉的解法就是用「遍历」的思路，我想应该没什么好说的：\nclass Solution: def __init__(self): self.res = [] # 返回前序遍历结果 def preorderTraversal(self, root: TreeNode) -\u0026gt; List[int]: self.traverse(root) return self.res # 二叉树遍历函数 def traverse(self, root: TreeNode): if root is None: return # 前序位置 self.res.append(root.val) self.traverse(root.left) self.traverse(root.right) 但你是否能够用「分解问题」的思路，来计算前序遍历的结果？\n换句话说，不要用像 traverse 这样的辅助函数和任何外部变量，单纯用题目给的 preorderTraverse 函数递归解题，你会不会？\n我们知道前序遍历的特点是，根节点的值排在首位，接着是左子树的前序遍历结果，最后是右子树的前序遍历结果：\n那这不就可以分解问题了么，一棵二叉树的前序遍历结果 = 根节点 + 左子树的前序遍历结果 + 右子树的前序遍历结果。\n所以，你可以这样实现前序遍历算法：\nclass Solution: # 定义：输入一棵二叉树的根节点，返回这棵树的前序遍历结果 def preorderTraversal(self, root): res = [] if root == None: return res # 前序遍历的结果，root.val 在第一个 res.append(root.val) # 利用函数定义，后面接着左子树的前序遍历结果 res.extend(self.preorderTraversal(root.left)) # 利用函数定义，最后接着右子树的前序遍历结果 res.extend(self.preorderTraversal(root.right)) return res 中序和后序遍历也是类似的，只要把 add(root.val) 放到中序和后序对应的位置就行了。\n综上，遇到一道二叉树的题目时的通用思考过程是：\n1、是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现。\n2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。\n3、无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做。\n后序位置的特殊之处 #\r说后序位置之前，先简单说下前序和中序。\n前序位置本身其实没有什么特别的性质，之所以你发现好像很多题都是在前序位置写代码，实际上是因为我们习惯把那些对前中后序位置不敏感的代码写在前序位置罢了。\n中序位置主要用在 BST 场景中，你完全可以把 BST 的中序遍历认为是遍历有序数组。\n[!tip]+ 划重点\n仔细观察，前中后序位置的代码，能力依次增强。\n前序位置的代码只能从函数参数中获取父节点传递来的数据。\n中序位置的代码不仅可以获取参数数据，还可以获取到左子树通过函数返回值传递回来的数据。\n后序位置的代码最强，不仅可以获取参数数据，还可以同时获取到左右子树通过函数返回值传递回来的数据。\n所以，某些情况下把代码移到后序位置效率最高；有些事情，只有后序位置的代码能做。\n举些具体的例子来感受下它们的能力区别。现在给你一棵二叉树，我问你两个简单的问题：\n1、如果把根节点看做第 1 层，如何打印出每一个节点所在的层数？\n2、如何打印出每个节点的左右子树各有多少节点？\n第一个问题可以这样写代码：\n# 二叉树遍历函数 def traverse(root, level): if root is None: return # 前序位置 print(f\u0026#34;Node {root.val} at level {level}\u0026#34;) traverse(root.left, level + 1) traverse(root.right, level + 1) # 这样调用 traverse(root, 1) 第二个问题可以这样写代码：\n# 定义：输入一棵二叉树，返回这棵二叉树的节点总数 def count(root): if root is None: return 0 leftCount = count(root.left) rightCount = count(root.right) # 后序位置 print(f\u0026#34;节点 {root} 的左子树有 {leftCount} 个节点，右子树有 {rightCount} 个节点\u0026#34;) return leftCount + rightCount + 1 这两个问题的根本区别在于\n一个节点在第几层，你从根节点遍历过来的过程就能顺带记录，用递归函数的参数就能传递下去；而以一个节点为根的整棵子树有多少个节点，你必须遍历完子树之后才能数清楚，然后通过递归函数的返回值拿到答案。\n结合这两个简单的问题，你品味一下后序位置的特点，只有后序位置才能通过返回值获取子树的信息。\n那么换句话说，一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了。\n接下来看下后序位置是如何在实际的题目中发挥作用的，简单聊下力扣第 543 题「二叉树的直径」，让你计算一棵二叉树的最长直径长度。\n所谓二叉树的「直径」长度，就是任意两个结点之间的路径长度。最长「直径」并不一定要穿过根结点，比如下面这棵二叉树：\n它的最长直径是 3，即 [4,2,1,3]，[4,2,1,9] 或者 [5,2,1,3] 这几条「直径」的长度。\n解决这题的关键在于，每一条二叉树的「直径」长度，就是一个节点的左右子树的最大深度之和。\n现在让我求整棵树中的最长「直径」，那直截了当的思路就是遍历整棵树中的每个节点，然后通过每个节点的左右子树的最大深度算出每个节点的「直径」，最后把所有「直径」求个最大值即可。\n最大深度的算法我们刚才实现过了，上述思路就可以写出以下代码：\nclass Solution: def __init__(self): # 记录最大直径的长度 self.maxDiameter = 0 def diameterOfBinaryTree(self, root): # 对每个节点计算直径，求最大直径 self.traverse(root) return self.maxDiameter # 遍历二叉树 def traverse(self, root): if root is None: return # 对每个节点计算直径 leftMax = self.maxDepth(root.left) rightMax = self.maxDepth(root.right) myDiameter = leftMax + rightMax # 更新全局最大直径 self.maxDiameter = max(self.maxDiameter, myDiameter) self.traverse(root.left) self.traverse(root.right) # 计算二叉树的最大深度 def maxDepth(self, root): if root is None: return 0 leftMax = self.maxDepth(root.left) rightMax = self.maxDepth(root.right) return 1 + max(leftMax, rightMax) 这个解法是正确的，但是运行时间很长，原因也很明显，traverse 遍历每个节点的时候还会调用递归函数 maxDepth，而 maxDepth 是要遍历子树的所有节点的，所以最坏时间复杂度是 O(N^2)。\n这就出现了刚才探讨的情况，前序位置无法获取子树信息，所以只能让每个节点调用 maxDepth 函数去算子树的深度。\n那如何优化？我们应该把计算「直径」的逻辑放在后序位置，准确说应该是放在 maxDepth 的后序位置，因为 maxDepth 的后序位置是知道左右子树的最大深度的。\n所以，稍微改一下代码逻辑即可得到更好的解法：\nclass Solution: def __init__(self): # 记录最大直径的长度 self.maxDiameter = 0 def diameterOfBinaryTree(self, root): self.maxDepth(root) return self.maxDiameter def maxDepth(self, root): if root is None: return 0 leftMax = self.maxDepth(root.left) rightMax = self.maxDepth(root.right) # 后序位置，顺便计算最大直径 myDiameter = leftMax + rightMax self.maxDiameter = max(self.maxDiameter, myDiameter) return 1 + max(leftMax, rightMax) 这下时间复杂度只有 maxDepth 函数的 O(N) 了。\n讲到这里，照应一下前文：遇到子树问题，首先想到的是给函数设置返回值，然后在后序位置做文章。\n[!tip] 利用后序位置的题目，一般都使用「分解问题」的思路。因为当前节点接收并利用了子树返回的信息，这就意味着你把原问题分解成了当前节点 + 左右子树的子问题。\n反过来，如果你写出了类似一开始的那种递归套递归的解法，大概率也需要反思是不是可以通过后序遍历优化了。\n以树的视角看动归/回溯/DFS 算法的区别和联系 #\r前文我说动态规划/回溯算法就是二叉树算法两种不同思路的表现形式，相信能看到这里的读者应该也认可了我这个观点。但有细心的读者经常提问：你的思考方法让我豁然开朗，但你好像一直没讲过 DFS 算法？\n因为 DFS 算法和回溯算法非常类似，只是在细节上有所区别。\n这个细节上的差别是什么呢？其实就是「做选择」和「撤销选择」到底在 for 循环外面还是里面的区别，DFS 算法在外面，回溯算法在里面。\n为什么有这个区别？还是要结合着二叉树理解。这一部分我就把回溯算法、DFS 算法、动态规划三种经典的算法思想，以及它们和二叉树算法的联系和区别，用一句话来说明：\n[!note]+ 划重点\n动归/DFS/回溯算法都可以看做二叉树问题的扩展，只是它们的关注点不同：\n动态规划算法属于分解问题（分治）的思路，它的关注点在整棵「子树」。 回溯算法属于遍历的思路，它的关注点在节点间的「树枝」。 DFS 算法属于遍历的思路，它的关注点在单个「节点」。 怎么理解？我分别举三个例子你就懂了。\n例子一：分解问题的思想体现 #\r第一个例子，给你一棵二叉树，请你用分解问题的思路写一个 count 函数，计算这棵二叉树共有多少个节点。代码很简单，上文都写过了：\n# 定义：输入一棵二叉树，返回这棵二叉树的节点总数 def count(root): if root is None: return 0 # 当前节点关心的是两个子树的节点总数分别是多少 # 因为用子问题的结果可以推导出原问题的结果 leftCount = count(root.left) rightCount = count(root.right) # 后序位置，左右子树节点数加上自己就是整棵树的节点数 return leftCount + rightCount + 1 你看，这就是动态规划分解问题的思路，它的着眼点永远是结构相同的整个子问题，类比到二叉树上就是「子树」。\n例子二：回溯算法的思想体现 #\r第二个例子，给你一棵二叉树，请你用遍历的思路写一个 traverse 函数，打印出遍历这棵二叉树的过程，你看下代码：\ndef traverse(root): if root is None: return print(\u0026#34;从节点 %s 进入节点 %s\u0026#34; %(root, root.left)) traverse(root.left) print(\u0026#34;从节点 %s 回到节点 %s\u0026#34; %(root.left, root)) print(\u0026#34;从节点 %s 进入节点 %s\u0026#34; %(root, root.right)) traverse(root.right) print(\u0026#34;从节点 %s 回到节点 %s\u0026#34; %(root.right, root)) 不难理解吧，好的，我们现在从二叉树进阶成多叉树，代码也是类似的：\n# 多叉树节点 class Node: def __init__(self, val=0, children=None): self.val = val self.children = children if children is not None else [] def traverse(root): if not root: return for child in root.children: print(f\u0026#34;从节点 {root} 进入节点 {child}\u0026#34;) traverse(child) print(f\u0026#34;从节点 {child} 回到节点 {root}\u0026#34;) 这个多叉树的遍历框架就可以延伸出 [[回溯算法（DFS算法）]]中的回溯算法框架：\n// 回溯算法框架 void backtrack(...) { // base case if (...) return; for (int i = 0; i \u0026lt; ...; i++) { // 做选择 ... // 进入下一层决策树 backtrack(...); // 撤销刚才做的选择 ... } } 你看，这就是回溯算法遍历的思路，它的着眼点永远是在节点之间移动的过程，类比到二叉树上就是「树枝」。\n你再看看具体的回溯算法问题，我们的关注点在一条条树枝上：\n// 回溯算法核心部分代码 void backtrack(int[] nums) { // 回溯算法框架 for (int i = 0; i \u0026lt; nums.length; i++) { // 做选择 used[i] = true; track.addLast(nums[i]); // 进入下一层回溯树 backtrack(nums); // 取消选择 track.removeLast(); used[i] = false; } } 例子三：DFS 的思想体现 #\r第三个例子，我给你一棵二叉树，请你写一个 traverse 函数，把这棵二叉树上的每个节点的值都加一。很简单吧，代码如下：\ndef traverse(root): if root is None: return # 遍历过的每个节点的值加一 root.val += 1 traverse(root.left) traverse(root.right) 你看，这就是 DFS 算法遍历的思路，它的着眼点永远是在单一的节点上，类比到二叉树上就是处理每个「节点」。\n","date":"2025-05-09","externalUrl":null,"permalink":"/posts/myfirstpost/","section":"Posts","summary":"二叉树算法纲领 #\r先在开头总结一下，二叉树解题的思维模式分两类：","title":"二叉树算法纲领","type":"posts"},{"content":"抽象地说，解决一个回溯问题，实际上就是遍历一棵决策树的过程，树的每个叶子节点存放着一个合法答案。你把整棵树遍历一遍，把叶子节点上的答案都收集起来，就能得到所有的合法答案。\n站在回溯树的一个节点上，你只需要思考 3 个问题：\n1、路径：也就是已经做出的选择。\n2、选择列表：也就是你当前可以做的选择。\n3、结束条件：也就是到达决策树底层，无法再做选择的条件。\n回溯算法的框架： #\rresult = [] def backtrack(路径, 选择列表): if 满足结束条件: result.add(路径) return for 选择 in 选择列表: 做选择 backtrack(路径, 选择列表) 撤销选择 其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」。\n[!warning] 与 DFS 算法的区别 就是「做选择」和「撤销选择」到底在 for 循环外面还是里面的区别，DFS 算法在外面，回溯算法在里面。\n[!tip] 划重点 动归/DFS/回溯算法都可以看做二叉树问题的扩展，只是它们的关注点不同：\n动态规划算法属于分解问题（分治）的思路，它的关注点在整棵「子树」。 回溯算法属于遍历的思路，它的关注点在节点间的「树枝」。 DFS 算法属于遍历的思路，它的关注点在单个「节点」。 例子： #\r全排列算法\n![[Pasted image 20250223173155.jpg]]\n分析 #\r只要从根遍历这棵树，记录路径上的数字，其实就是所有的全排列。我们不妨把这棵树称为回溯算法的「决策树」。\n为啥说这是决策树呢，因为你在每个节点上其实都在做决策。比如说你站在下图的红色节点上：\n你现在就在做决策，可以选择 1 那条树枝，也可以选择 3 那条树枝。为啥只能在 1 和 3 之中选择呢？因为 2 这个树枝在你身后，这个选择你之前做过了，而全排列是不允许重复使用数字的。\n现在可以解答开头的几个名词：[2] 就是「路径」，记录你已经做过的选择；[1,3] 就是「选择列表」，表示你当前可以做出的选择；「结束条件」就是遍历到树的底层叶子节点，这里也就是选择列表为空的时候。\n如果明白了这几个名词，可以把「路径」和「选择」列表作为决策树上每个节点的属性，比如下图列出了几个蓝色节点的属性：\n我们定义的 backtrack 函数其实就像一个指针，在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层叶子节点，其「路径」就是一个全排列。![[Pasted image 20250223173357.jpg]]\n代码 #\rfrom typing import List class Solution: def __init__(self): self.res = [] # 主函数，输入一组不重复的数字，返回它们的全排列 def permute(self, nums: List[int]) -\u0026gt; List[List[int]]: # 记录「路径」 track = [] # 「路径」中的元素会被标记为 true，避免重复使用 used = [False] * len(nums) self.backtrack(nums, track, used) return self.res # 路径：记录在 track 中 # 选择列表：nums 中不存在于 track 的那些元素（used[i] 为 false） # 结束条件：nums 中的元素全都在 track 中出现 def backtrack(self, nums: List[int], track: List[int], used: List[bool]): # 触发结束条件 if len(track) == len(nums): self.res.append(track.copy()) return for i in range(len(nums)): # 排除不合法的选择 if used[i]: # nums[i] 已经在 track 中，跳过 continue # 做选择 track.append(nums[i]) used[i] = True # 进入下一层决策树 self.backtrack(nums, track, used) # 取消选择 track.pop() used[i] = False ","date":"2025-05-09","externalUrl":null,"permalink":"/posts/mypage4/","section":"Posts","summary":"抽象地说，解决一个回溯问题，实际上就是遍历一棵决策树的过程，树的每个叶子节点存放着一个合法答案。你把整棵树遍历一遍，把叶子节点上的答案都收集起来，就能得到所有的合法答案。","title":"回溯算法","type":"posts"},{"content":"","date":"2025-05-09","externalUrl":null,"permalink":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","section":"Tags","summary":"","title":"数据结构","type":"tags"},{"content":"","date":"2025-05-09","externalUrl":null,"permalink":"/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"\r有向加权图（邻接表实现） #\r我这里给出一个简单的通用实现，后文图论算法教程和习题中可能会用到。其中有一些可以优化的点我写在注释中了。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;stdexcept\u0026gt; using namespace std; // 加权有向图的通用实现（邻接表） class WeightedDigraph { public: // 存储相邻节点及边的权重 struct Edge { int to; int weight; Edge(int to, int weight) { this-\u0026gt;to = to; this-\u0026gt;weight = weight; } }; private: // 邻接表，graph[v] 存储节点 v 的所有邻居节点及对应权重 vector\u0026lt;vector\u0026lt;Edge\u0026gt;\u0026gt; graph; public: WeightedDigraph(int n) { // 我们这里简单起见，建图时要传入节点总数，这其实可以优化 // 比如把 graph 设置为 Map\u0026lt;Integer, List\u0026lt;Edge\u0026gt;\u0026gt;，就可以动态添加新节点了 graph = vector\u0026lt;vector\u0026lt;Edge\u0026gt;\u0026gt;(n); } // 增，添加一条带权重的有向边，复杂度 O(1) void addEdge(int from, int to, int weight) { graph[from].emplace_back(to, weight); } // 删，删除一条有向边，复杂度 O(V) void removeEdge(int from, int to) { for (auto it = graph[from].begin(); it != graph[from].end(); ++it) { if (it-\u0026gt;to == to) { graph[from].erase(it); break; } } } // 查，判断两个节点是否相邻，复杂度 O(V) bool hasEdge(int from, int to) { for (const auto\u0026amp; e : graph[from]) { if (e.to == to) { return true; } } return false; } // 查，返回一条边的权重，复杂度 O(V) int weight(int from, int to) { for (const auto\u0026amp; e : graph[from]) { if (e.to == to) { return e.weight; } } throw invalid_argument(\u0026#34;No such edge\u0026#34;); } // 查，返回某个节点的所有邻居节点，复杂度 O(1) const vector\u0026lt;Edge\u0026gt;\u0026amp; neighbors(int v) { return graph[v]; } }; int main() { WeightedDigraph graph(3); graph.addEdge(0, 1, 1); graph.addEdge(1, 2, 2); graph.addEdge(2, 0, 3); graph.addEdge(2, 1, 4); cout \u0026lt;\u0026lt; boolalpha \u0026lt;\u0026lt; graph.hasEdge(0, 1) \u0026lt;\u0026lt; endl; // true cout \u0026lt;\u0026lt; boolalpha \u0026lt;\u0026lt; graph.hasEdge(1, 0) \u0026lt;\u0026lt; endl; // false for (const auto\u0026amp; edge : graph.neighbors(2)) { cout \u0026lt;\u0026lt; \u0026#34;2 -\u0026gt; \u0026#34; \u0026lt;\u0026lt; edge.to \u0026lt;\u0026lt; \u0026#34;, wight: \u0026#34; \u0026lt;\u0026lt; edge.weight \u0026lt;\u0026lt; endl; } // 2 -\u0026gt; 0, wight: 3 // 2 -\u0026gt; 1, wight: 4 graph.removeEdge(0, 1); cout \u0026lt;\u0026lt; boolalpha \u0026lt;\u0026lt; graph.hasEdge(0, 1) \u0026lt;\u0026lt; endl; // false return 0; } 有向加权图（邻接矩阵实现） #\r没啥可说的，具体看代码和注释吧：\nint** matrix = new int*[m]; //new int(5) 或者 new int[5]() 或者 new int[3]{1,2,3} for (int i = 0; i \u0026lt; m; i++) { matrix[i] = new int[n](); // 分配并初始化为 0 } // 使用示例 matrix[0][1] = 42; // 访问元素 // 释放内存 for (int i = 0; i \u0026lt; m; ++i) { delete[] matrix[i]; } delete[] matrix; #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; // 加权有向图的通用实现（邻接矩阵） class WeightedDigraph { public: // 存储相邻节点及边的权重 struct Edge { int to; int weight; Edge(int to, int weight) : to(to), weight(weight) {} }; WeightedDigraph(int n) { matrix = vector\u0026lt; vector\u0026lt;int\u0026gt;\u0026gt;(n, vector\u0026lt;int\u0026gt;(n, 0)); } // 增，添加一条带权重的有向边，复杂度 O(1) void addEdge(int from, int to, int weight) { matrix[from][to] = weight; } // 删，删除一条有向边，复杂度 O(1) void removeEdge(int from, int to) { matrix[from][to] = 0; } // 查，判断两个节点是否相邻，复杂度 O(1) bool hasEdge(int from, int to) { return matrix[from][to] != 0; } // 查，返回一条边的权重，复杂度 O(1) int weight(int from, int to) { return matrix[from][to]; } // 查，返回某个节点的所有邻居节点，复杂度 O(V) vector\u0026lt;Edge\u0026gt; neighbors(int v) { vector\u0026lt;Edge\u0026gt; res; for (int i = 0; i \u0026lt; matrix[v].size(); i++) { if (matrix[v][i] \u0026gt; 0) { res.push_back(Edge(i, matrix[v][i])); } } return res; } private: // 邻接矩阵，matrix[from][to] 存储从节点 from 到节点 to 的边的权重 // 0 表示没有连接 vector\u0026lt; vector\u0026lt;int\u0026gt;\u0026gt; matrix; }; int main() { WeightedDigraph graph(3); graph.addEdge(0, 1, 1); graph.addEdge(1, 2, 2); graph.addEdge(2, 0, 3); graph.addEdge(2, 1, 4); cout \u0026lt;\u0026lt; boolalpha; cout \u0026lt;\u0026lt; graph.hasEdge(0, 1) \u0026lt;\u0026lt; endl; // true cout \u0026lt;\u0026lt; graph.hasEdge(1, 0) \u0026lt;\u0026lt; endl; // false for (const auto\u0026amp; edge : graph.neighbors(2)) { cout \u0026lt;\u0026lt; \u0026#34;2 -\u0026gt; \u0026#34; \u0026lt;\u0026lt; edge.to \u0026lt;\u0026lt; \u0026#34;, weight: \u0026#34; \u0026lt;\u0026lt; edge.weight \u0026lt;\u0026lt; endl; } // 2 -\u0026gt; 0, weight: 3 // 2 -\u0026gt; 1, weight: 4 graph.removeEdge(0, 1); cout \u0026lt;\u0026lt; graph.hasEdge(0, 1) \u0026lt;\u0026lt; endl; // false return 0; } 有向无权图（邻接表/邻接矩阵实现） #\r直接复用上面的 WeightedDigraph 类就行，把 addEdge 方法的权重参数默认设置为 1 就行了。比较简单，我就不写代码了。\n无向加权图（邻接表/邻接矩阵实现） #\r无向加权图就等同于双向的有向加权图，所以直接复用上面用邻接表/领接矩阵实现的 WeightedDigraph 类就行了，只是在增加边的时候，要同时添加两条边：\n// 无向加权图的通用实现 class WeightedUndigraph { private: WeightedDigraph graph; public: WeightedUndigraph(int n) : graph(n) {} // 增，添加一条带权重的无向边 void addEdge(int from, int to, int weight) { graph.addEdge(from, to, weight); graph.addEdge(to, from, weight); } // 删，删除一条无向边 void removeEdge(int from, int to) { graph.removeEdge(from, to); graph.removeEdge(to, from); } // 查，判断两个节点是否相邻 bool hasEdge(int from, int to) { return graph.hasEdge(from, to); } // 查，返回一条边的权重 int weight(int from, int to) { return graph.weight(from, to); } // 查，返回某个节点的所有邻居节点 const vector\u0026lt;WeightedDigraph::Edge\u0026gt;\u0026amp; neighbors(int v) const { return graph.neighbors(v); } }; int main() { WeightedUndigraph graph(3); graph.addEdge(0, 1, 1); graph.addEdge(1, 2, 2); graph.addEdge(2, 0, 3); graph.addEdge(2, 1, 4); cout \u0026lt;\u0026lt; boolalpha \u0026lt;\u0026lt; graph.hasEdge(0, 1) \u0026lt;\u0026lt; endl; // true cout \u0026lt;\u0026lt; boolalpha \u0026lt;\u0026lt; graph.hasEdge(1, 0) \u0026lt;\u0026lt; endl; // true for (const auto\u0026amp; edge : graph.neighbors(2)) { cout \u0026lt;\u0026lt; \u0026#34;2 \u0026lt;-\u0026gt; \u0026#34; \u0026lt;\u0026lt; edge.to \u0026lt;\u0026lt; \u0026#34;, weight: \u0026#34; \u0026lt;\u0026lt; edge.weight \u0026lt;\u0026lt; endl; } // 2 \u0026lt;-\u0026gt; 0, weight: 3 // 2 \u0026lt;-\u0026gt; 1, weight: 4 graph.removeEdge(0, 1); cout \u0026lt;\u0026lt; boolalpha \u0026lt;\u0026lt; graph.hasEdge(0, 1) \u0026lt;\u0026lt; endl; // false cout \u0026lt;\u0026lt; boolalpha \u0026lt;\u0026lt; graph.hasEdge(1, 0) \u0026lt;\u0026lt; endl; // false return 0; } 无向无权图（邻接表/邻接矩阵实现） #\r直接复用上面的 WeightedUndigraph 类就行，把 addEdge 方法的权重参数默认设置为 1 就行了。比较简单，我就不写代码了。\nDFS 遍历 #\r顶点遍历 #\r// 遍历图的所有节点 void traverse(const Graph\u0026amp; graph, int s, vector\u0026lt;bool\u0026gt;\u0026amp; visited) { // base case if (s \u0026lt; 0 || s \u0026gt;= graph.size()) { return; } if (visited[s]) { // 防止死循环 return; } // 前序位置 visited[s] = true; cout \u0026lt;\u0026lt; \u0026#34;visit \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; for (const Graph::Edge\u0026amp; e : graph.neighbors(s)) { traverse(graph, e.to, visited); } // 后序位置 } 边遍历 #\r// 下面的算法代码可以遍历图的所有路径，寻找从 src 到 dest 的所有路径 // onPath 和 path 记录当前递归路径上的节点 vector\u0026lt;bool\u0026gt; onPath(graph.size()); list\u0026lt;int\u0026gt; path; void traverse(Graph\u0026amp; graph, int src, int dest) { // base case if (src \u0026lt; 0 || src \u0026gt;= graph.size()) { return; } if (onPath[src]) { // 防止死循环（成环） return; } // 前序位置 onPath[src] = true; path.push_back(src); if (src == dest) { cout \u0026lt;\u0026lt; \u0026#34;find path: \u0026#34;; for (int node : path) { cout \u0026lt;\u0026lt; node \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } for (const Edge\u0026amp; e : graph.neighbors(src)) { traverse(graph, e.to, dest); } // 后序位置 path.pop_back(); onPath[src] = false; } BFS 遍历 #\r写法一 #\r第一种写法是不记录遍历步数的：\n// 多叉树的层序遍历 void levelOrderTraverse(Node* root) { if (root == nullptr) { return; } queue\u0026lt;Node*\u0026gt; q; q.push(root); while (!q.empty()) { Node* cur = q.front(); q.pop(); // 访问 cur 节点 cout \u0026lt;\u0026lt; cur-\u0026gt;val \u0026lt;\u0026lt; endl; // 把 cur 的所有子节点加入队列 for (Node* child : cur-\u0026gt;children) { q.push(child); } } } // 图结构的 BFS 遍历，从节点 s 开始进行 BFS void bfs(const Graph\u0026amp; graph, int s) { vector\u0026lt;bool\u0026gt; visited(graph.size(), false); queue\u0026lt;int\u0026gt; q; q.push(s); visited[s] = true; while (!q.empty()) { int cur = q.front(); q.pop(); cout \u0026lt;\u0026lt; \u0026#34;visit \u0026#34; \u0026lt;\u0026lt; cur \u0026lt;\u0026lt; endl; for (const Edge\u0026amp; e : graph.neighbors(cur)) { if (!visited[e.to]) { q.push(e.to); visited[e.to] = true; } } } } 写法二 #\r第二种能够记录遍历步数的写法：\n// 多叉树的层序遍历 void levelOrderTraverse(Node* root) { if (root == nullptr) { return; } queue\u0026lt;Node*\u0026gt; q; q.push(root); // 记录当前遍历到的层数（根节点视为第 1 层） int depth = 1; while (!q.empty()) { int sz = q.size(); for (int i = 0; i \u0026lt; sz; i++) { Node* cur = q.front(); q.pop(); // 访问 cur 节点，同时知道它所在的层数 cout \u0026lt;\u0026lt; \u0026#34;depth = \u0026#34; \u0026lt;\u0026lt; depth \u0026lt;\u0026lt; \u0026#34;, val = \u0026#34; \u0026lt;\u0026lt; cur-\u0026gt;val \u0026lt;\u0026lt; endl; for (Node* child : cur-\u0026gt;children) { q.push(child); } } depth++; } } // 从 s 开始 BFS 遍历图的所有节点，且记录遍历的步数 void bfs(const Graph\u0026amp; graph, int s) { vector\u0026lt;bool\u0026gt; visited(graph.size(), false); queue\u0026lt;int\u0026gt; q; q.push(s); visited[s] = true; // 记录从 s 开始走到当前节点的步数 int step = 0; while (!q.empty()) { int sz = q.size(); for (int i = 0; i \u0026lt; sz; i++) { int cur = q.front(); q.pop(); cout \u0026lt;\u0026lt; \u0026#34;visit \u0026#34; \u0026lt;\u0026lt; cur \u0026lt;\u0026lt; \u0026#34; at step \u0026#34; \u0026lt;\u0026lt; step \u0026lt;\u0026lt; endl; for (const Edge\u0026amp; e : graph.neighbors(cur)) { if (!visited[e.to]) { q.push(e.to); visited[e.to] = true; } } } step++; } } 这个 step 变量记录了从起点 s 开始的遍历步数，对于无权图来说，相当于每条边的权重都是 1，这个变量就可以辅助我们判断最短路径。\n写法三 #\r第三种能够适配不同权重边的写法：\n// 多叉树的层序遍历 // 每个节点自行维护 State 类，记录深度等信息 class State { public: Node* node; int depth; State(Node* node, int depth) : node(node), depth(depth) {} }; void levelOrderTraverse(Node* root) { if (root == nullptr) { return; } queue\u0026lt;State\u0026gt; q; // 记录当前遍历到的层数（根节点视为第 1 层） q.push(State(root, 1)); while (!q.empty()) { State state = q.front(); q.pop(); Node* cur = state.node; int depth = state.depth; // 访问 cur 节点，同时知道它所在的层数 cout \u0026lt;\u0026lt; \u0026#34;depth = \u0026#34; \u0026lt;\u0026lt; depth \u0026lt;\u0026lt; \u0026#34;, val = \u0026#34; \u0026lt;\u0026lt; cur-\u0026gt;val \u0026lt;\u0026lt; endl; for (Node* child : cur-\u0026gt;children) { q.push(State(child, depth + 1)); } } } // 图结构的 BFS 遍历，从节点 s 开始进行 BFS，且记录路径的权重和 // 每个节点自行维护 State 类，记录从 s 走来的权重和 class State { public: // 当前节点 ID int node; // 从起点 s 到当前节点的权重和 int weight; State(int node, int weight) : node(node), weight(weight) {} }; void bfs(const Graph\u0026amp; graph, int s) { vector\u0026lt;bool\u0026gt; visited(graph.size(), false); queue\u0026lt;State\u0026gt; q; q.push(State(s, 0)); visited[s] = true; while (!q.empty()) { State state = q.front(); q.pop(); int cur = state.node; int weight = state.weight; cout \u0026lt;\u0026lt; \u0026#34;visit \u0026#34; \u0026lt;\u0026lt; cur \u0026lt;\u0026lt; \u0026#34; with path weight \u0026#34; \u0026lt;\u0026lt; weight \u0026lt;\u0026lt; endl; for (const Edge\u0026amp; e : graph.neighbors(cur)) { if (!visited[e.to]) { q.push(State(e.to, weight + e.weight)); visited[e.to] = true; } } } } 对于加权图，由于每条边的权重不同，遍历的步数不再能代表最短路径的长度，所以需要每个节点用自定义 State 类维护自己的路径权重和，最典型的例子就是 Dijkstra 单源最短路径算法 了。\n","date":"2025-05-09","externalUrl":null,"permalink":"/posts/mypage3/","section":"Posts","summary":"有向加权图（邻接表实现） #\r我这里给出一个简单的通用实现，后文图论算法教程和习题中可能会用到。其中有一些可以优化的点我写在注释中了。","title":"图论","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]